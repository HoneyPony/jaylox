use core::fmt;
use std::collections::HashMap;
use std::{collections::HashSet, fmt::Write};

use crate::ir::{Ir, IrCompiler, IrFunction, IrVals};
use crate::stmt::{Class, Function};
use crate::{CodegenOptions, VarRef};
use crate::{expr::Expr, scanner::Token, stmt::Stmt, Lox};
use crate::scanner::{LoxValue, TokenType};
use crate::scanner::TokenType::*;


pub struct Compiler<'a, Writer: std::io::Write> {
	pub lox: &'a mut Lox,

	/// Contains the #include and all function forward-declarations.
	prelude: String,

	/// Contains all the function definitions.
	function_defs: Vec<String>,

	/// Contains every string used for names. This is for the fast hashing system.
	name_set: HashSet<String>,

	current_indent: i32,

	/// Tracks whether we currently have a 'locals' frame (wrt 'return' statements.)
	has_locals_frame: bool,

	/// Tracks whether we currently have a 'captures' frame.
	has_captures_frame: bool,

	/// Keeps track of how many hops each captured variable is from the current function.
	/// Each function that creates a dynamic scope / closure will increase the hops
	/// of all captured variables by 1 (and add its own); otherwise, the hops stay the same,
	/// which should reduce pointer chasing.
	/// 
	/// (We could implement it in a way with even less pointer chasing, but this is a good
	/// starting point)
	captured_depths: HashMap<VarRef, u32>,

	/// The set of strings that we've already used as function names.
	mangled_set: HashSet<String>,

	writer: Writer,

	opt: CodegenOptions,

	vals: IrVals,
}

impl<'a, Writer: std::io::Write> Compiler<'a, Writer> {
	pub fn new(lox: &'a mut Lox, vals: IrVals, writer: Writer, opt: CodegenOptions) -> Self {
		return Compiler {
			lox,
			prelude: String::new(),
			function_defs: Vec::new(),
			name_set: HashSet::new(),
			current_indent: 0,

			// The main function has no locals frame or captures frame.
			has_locals_frame: false,
			has_captures_frame: false,

			captured_depths: HashMap::new(),

			mangled_set: HashSet::new(),

			writer,

			opt,

			vals
		}
	}

	fn mangle(&mut self, starting_point: String) -> String {
		// "Fast" path: If the name is unused, just use it (and track so)
		if !self.mangled_set.contains(&starting_point) {
			self.mangled_set.insert(starting_point.clone());
			return starting_point;
		}

		let mut suffix: u64 = 0;
		loop {
			let candidate: String = format!("{}_{}", starting_point, suffix);
			if !self.mangled_set.contains(&candidate) {
				self.mangled_set.insert(candidate.clone());
				return candidate;
			}

			// There is no way we get through all values of u64 without colliding...
			suffix += 1;
		}
	}

	fn push_indent(&mut self) {
		self.current_indent += 1;
	}

	fn pop_indent(&mut self) {
		self.current_indent -= 1;
	}

	fn indent(&self, into: &mut String) {
		for _ in 0..self.current_indent {
			into.push('\t');
		}
	}

	fn add_name(&mut self, name: &Token) {
		if self.name_set.contains(&name.lexeme) { return; }
		self.name_set.insert(name.lexeme.clone());
	}

	fn compile_literal_inline(&mut self, into: &mut String, lit: &LoxValue) -> fmt::Result {
		match lit {
			LoxValue::Nil => into.push_str("jay_box_nil()"),
			LoxValue::String(ptr) => {
				// String constants are looked up inside a global array, so
				// that we only have to initialize them once.
				write!(into, "global_string_constants[{}]", ptr.to_number())?;
			},
			LoxValue::Number(value) => write!(into, "jay_box_number({value})")?,
			LoxValue::Bool(value) => write!(into, "jay_box_bool({value})")?,
		}

		Ok(())
	}

	fn compile_var(&mut self, var: VarRef, into: &mut String) -> fmt::Result {
		match self.lox.get_var_type(var) {
			crate::VarType::Local => {
				write!(into, "locals.at[{}]", self.lox.get_var_mut(var).index)
			},
			crate::VarType::Parameter => {
				write!(into, "args[{}]", self.lox.get_var_mut(var).index)
			},
			// CapturedParameters are made to be handled the same, based on
			// some special code generated by compile_function()
			crate::VarType::Captured | crate::VarType::CapturedParameter(_) => {
				// Here, based on the depth, we add some number of "parent" traversals
				// to the current "closure".
				//
				// If this function created a new scope than:
				//   "closure" == depth of 1.
				//   "scope" == depth of 0.
				//   "closure->parent" == depth of 2.
				// otherwise,
				//   "closure" == "scope" == depth of 0.
				//   "closure->parent" == depth of 1.
				//
				// Note that we could always do scope = 0, scope->parent = 1,
				// and so forth, but this doesn't let us make use of the fact
				// that scope->parent == closure in some cases.
				// 
				// This is due to the fact that we distinguish between the current
				// scope and the closure passed in.
				let depth = *self.captured_depths.get(&var)
					.expect("Internal compiler error: Tried to access invalid captured variable info.");
				let index = self.lox.get_var_mut(var).index;

				if depth == 0 && self.has_captures_frame {
					write!(into, "scope->values[{index}]")?;
				}
				else {
					// The hops amount is 'depth' if our scope == closure. This is because
					// hopping to closure would usually hop us up one, but because we didn't
					// create a scope, it instead hopped us up 0.
					//
					// If captures does hop us up 1, then to get to depth only requires depth - 1
					// more steps.
					let hops = if self.has_captures_frame { depth - 1 } else { depth };
					write!(into, "closure->")?;
					// Walk up correct number of parents.
					for _ in 0..hops {
						write!(into, "parent->")?;
					}
					// Finally, access the values array.
					write!(into, "values[{index}]")?;
				}

				Ok(())
			},
			crate::VarType::Global => {
				write!(into, "globals[{}]", self.lox.get_var_mut(var).index)
			}
		}
	}

	fn compile_ir(&mut self, ir: &Ir, into: &mut String) -> fmt::Result {
		match ir {
			Ir::Binop { output, left, right, op } => todo!(),
			Ir::This { output } => todo!(),
			Ir::Call { output, callee, arity } => todo!(),
			Ir::If { input, then_branch, else_branch } => todo!(),
			Ir::Print { input } => todo!(),
			Ir::Literal { output, literal } => todo!(),
			Ir::Assign { output, identity, value } => todo!(),
			Ir::Block(_) => todo!(),
		}

		Ok(())
	}

	fn compile_ir_block(&mut self, stmts: &Vec<Ir>, into: &mut String) -> fmt::Result {
		for ir in stmts {
			self.compile_ir(ir, into)?;
		}

		Ok(())
	}

	fn compile_to_buffers(&mut self, fun: &IrFunction, globals_count: u32) -> Result<String, fmt::Error> {
		// Write the first part of the prelude
		writeln!(self.prelude, "/*** This C file created by jaylox https://github.com/HoneyPony/jaylox ***/")?;
		if self.opt.gc_stress_test {
			writeln!(self.prelude, "#define JAY_GC_STRESS_TEST")?;
		}
		if self.opt.nan_boxing {
			writeln!(self.prelude, "#define JAY_NAN_BOXING")?;
		}
		if self.opt.assume_correct {
			writeln!(self.prelude, "#define JAY_ASSUME_CORRECT")?;
		}
		writeln!(self.prelude, "#include \"jaylib/jaylib.h\"\n")?;

		// Write the globals array to the prelude (and the string constants array)
		writeln!(self.prelude, "static jay_value globals[{globals_count}];")?;
		writeln!(self.prelude, "static jay_value global_string_constants[{}];\n", self.lox.string_constants.len())?;

		// Create the global-visit function
		writeln!(self.prelude, "static\nvoid\njay_gc_visit_globals(void) {{")?;
		writeln!(self.prelude, "\tfor(size_t i = 0; i < {globals_count}; ++i) {{")?;
		writeln!(self.prelude, "#ifdef JAY_TRACE_GC_DIRECT")?;
		writeln!(self.prelude, "\t\tprintf(\"gc: visit global %zu \", i);")?;
		writeln!(self.prelude, "\t\tjay_print(globals[i]);")?;
		writeln!(self.prelude, "#endif")?;
		writeln!(self.prelude, "\t\tjay_gc_visit(&globals[i]);")?;
		writeln!(self.prelude, "\t}}")?;
		// For now, we also have to copy the string constants over, although this should change
		// later (make them immortal)
		writeln!(self.prelude, "\tfor(size_t i = 0; i < {}; ++i) {{", self.lox.string_constants.len())?;
		writeln!(self.prelude, "#ifdef JAY_TRACE_GC_DIRECT")?;
		writeln!(self.prelude, "\t\tprintf(\"gc: visit string constant %zu \", i);")?;
		writeln!(self.prelude, "\t\tjay_print(global_string_constants[i]);")?;
		writeln!(self.prelude, "#endif")?;
		writeln!(self.prelude, "\t\tjay_gc_visit(&global_string_constants[i]);")?;
		writeln!(self.prelude, "\t}}")?;
		writeln!(self.prelude, "}}\n")?;

		let mut main_fn = String::new();

		// TODO: Consider creating an efficient string writing system
		// In particular, each function being compiled will need its own string...
		self.push_indent();

		// The most important responsibility of main() is initializing the gc and stack
		if self.opt.gc_stress_test {
			writeln!(main_fn, "\tjay_gc_init(512); // STRESS_TEST: small initial heap")?;
		}
		else {
			writeln!(main_fn, "\tjay_gc_init(16 * 1024 * 1024); // 16 megabytes")?;
		}
		writeln!(main_fn, "\tjay_stack_ptr = jay_stack;")?;
		writeln!(main_fn, "\tjay_frames_ptr = 0;\n")?;

		// We have to set up all the string constants in main for the rest of the
		// code to use.
		for (idx, constant) in self.lox.string_constants.iter().enumerate() {
			writeln!(main_fn, "\tglobal_string_constants[{idx}] = jay_box_string(jay_string_from_literal(\"{constant}\"));")?;
		}

		// Note: Built-in functions will also be set up in main, but this requires
		// parser support..?

		self.indent(&mut main_fn);
		// Create the scope for the main fn
		writeln!(main_fn, "jay_closure *scope = NULL;")?;

		// Compile the actual top-level code (any normal statements will go
		// into main; other things will go into their own functions)
		self.compile_ir_block(&fun.code, &mut main_fn)?;
		self.pop_indent();

		Ok(main_fn)
	}

	pub fn compile(&mut self, main: &IrFunction, globals_count: u32) -> std::io::Result<()> {
		// We use write! a lot and so get fmt::Result, but most of the compilation
		// process should not fail (unless we OOM or something). By contrast, it
		// is very possible that, while writing out to the self.writer, there is
		// an error (e.g. read-only file target).
		//
		// So, wrap all of the compiling-to-buffers in its own function, and assume
		// that it almost certainly won't error. Then, the error from writing to
		// self.writer can be returned to the caller.
		let main_fn = match self.compile_to_buffers(main, globals_count) {
			Ok(main_fn) => main_fn,
			Err(err) => {
				panic!("Compiler error while writing to buffers: {}", err);
			}
		};

		// First: prelude, containing all function declarations
		write!(self.writer, "{}", self.prelude)?;

		writeln!(self.writer, "\n/* --- NAME Definitions --- */\n")?;

		// Second, NAME_ definitions
		// Note that 0 is the TOMBSTONE so we cannot use it for a NAME
		let mut name_value: usize = 1;
		for name in &self.name_set {
			writeln!(self.writer, "#define NAME_{name} ((jay_name){name_value})")?;
			name_value += 1;
		}
		writeln!(self.writer, "\n/* --- Function Definitions --- */\n")?;

		// Third, function definitions
		for fun in &self.function_defs {
			write!(self.writer, "{}", fun)?;
		}

		writeln!(self.writer, "\n/* --- main() --- */\n")?;

		// Last, main function definition (could go earlier too)
		write!(self.writer, "int\nmain(void) {{\n{}}}\n", main_fn)?;

		Ok(())
	}
}