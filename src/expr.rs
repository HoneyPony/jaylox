use crate::Lox;

// This file is generated by build.rs
include!(concat!(env!("OUT_DIR"), "/expr.gen.rs"));

pub struct ExprErr;

pub type ExprRes = Result<Expr, ExprErr>;

impl Expr {
	fn bi_fold_numerical(left: LoxValue, operator: Token, right: LoxValue, lox: &mut Lox) -> Result<LoxValue, ExprErr> {
		let LoxValue::Number(left) = left else {
			lox.error_token(&operator, "Left operand to operator must be numerical.");
			return Err(ExprErr);
		};

		let LoxValue::Number(right) = right else {
			lox.error_token(&operator, "Right operand to operator must be numerical.");
			return Err(ExprErr);
		};

		// Now that both operands are correct, we can use the operator to compute
		// the folded value.
		let folded = match operator.typ {
			// Note: Plus is technically unused here, but whatever
			TokenType::Plus => LoxValue::Number(left + right),

			// Other number op number => number
			TokenType::Minus => LoxValue::Number(left - right),
			TokenType::Star => LoxValue::Number(left * right),
			TokenType::Slash => LoxValue::Number(left / right),

			// number op number => bool
			TokenType::Less => LoxValue::Bool(left < right),
			TokenType::LessEqual => LoxValue::Bool(left <= right),
			TokenType::Greater => LoxValue::Bool(left > right),
			TokenType::GreaterEqual => LoxValue::Bool(left >= right),

			_ => unreachable!()
		};

		Ok(folded)
	}

	fn bi_fold_logical(left: LoxValue, operator: Token, right: LoxValue) -> Result<LoxValue, ExprErr> {
		// The short-circuiting semantic is that, if the right operand does not need
		// to be evaluated, the left one is returned. So, we have to implement that here.
		//
		// Note this is essentially equivalent to the interpreter.
		let folded = match operator.typ {
			TokenType::And => if !left.is_truthy() { left } else { right }
			TokenType::Or  => if  left.is_truthy() { left } else { right },

			_ => unreachable!()
		};

		Ok(folded)
	}

	fn bi_fold(left: LoxValue, operator: Token, right: LoxValue, lox: &mut Lox) -> Result<LoxValue, ExprErr> {
		match operator.typ {
			TokenType::Minus | TokenType::Star | TokenType::Slash | 
			TokenType::Less | TokenType::LessEqual |
			TokenType::Greater | TokenType::GreaterEqual => Self::bi_fold_numerical(left, operator, right, lox),

			TokenType::And | TokenType::Or => Self::bi_fold_logical(left, operator, right),

			TokenType::Plus => {
				match (left, right) {
					(LoxValue::Number(a), LoxValue::Number(b)) => {
						return Ok(LoxValue::Number(a + b));
					},
					(LoxValue::String(a), LoxValue::String(b)) => {
						let concatenated = format!("{}{}", lox.get_string_constant(a), lox.get_string_constant(b));
						let rc = lox.put_string_constant(concatenated);
						return Ok(LoxValue::String(rc));
					},
					_ => {
						lox.error_token(&operator, "Operands to '+' must both be numbers or both be strings.");
						return Err(ExprErr);
					}
				}
			},

			_ => unreachable!()
		}
	}

	// TODO: Consider NOT propogating an error up the call stack when constant folding fails,
	// as it isn't actually a parse error but rather a semantic error.
	pub fn binary_folded(left: Expr, operator: Token, right: Expr, lox: &mut Lox) -> Result<Expr, ExprErr> {
		match (left, right) {
			(Expr::Literal(a), Expr::Literal(b)) => {
				Ok(Expr::Literal(Self::bi_fold(a, operator,b, lox)?))
			},
			(l, r) => {
				Ok(Self::binary(l, operator, r))
			},
		}
	}
}