// This file is generated by build.rs
include!(concat!(env!("OUT_DIR"), "/expr.gen.rs"));

pub struct ExprErr;

pub type ExprRes = Result<Expr, ExprErr>;

#[allow(unused)]
fn paren_begin(marker: &str) {
	print!("({}", marker);
}

#[allow(unused)]
fn paren_middle(expr: &Expr) {
	print!(" ");
	ast_print(expr);
}

#[allow(unused)]
fn paren_end(expr: &Expr) {
	print!(" ");
	ast_print(expr);
	print!(")");
}

#[allow(unused)]
pub fn ast_print(expr: &Expr) {
	match expr {
		Expr::Binary { left, operator, right } => {
			paren_begin(&operator.lexeme);
			paren_middle(left);
			paren_end(right);
		},
		Expr::Grouping(expr) => {
			paren_begin("group");
			paren_end(expr);
		},
		Expr::Literal(lit) => {
			print!("{}", lit.to_string());
		}
		Expr::Unary { operator, right } => {
			paren_begin(&operator.lexeme);
			paren_end(right);
		},
		Expr::Variable(var) => {
			print!("{}", var.lexeme);
		},
		Expr::Assign { name, value } => {
			paren_begin("assign");
			print!(" {}", name.lexeme);
			paren_end(value);
		}
	}
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ast_print() {
		let minus = Token::new(TokenType::Minus, "-".into(), TokenLiteral::None, 1);
		let star = Token::new(TokenType::Star, "*".into(), TokenLiteral::None, 1);

        let expr = Expr::binary(
			Expr::unary(minus, Expr::literal(TokenLiteral::Number(123.0))),
			star,
			Expr::grouping(Expr::literal(TokenLiteral::Number(45.67)))
		);

		ast_print(&expr);
    }
}